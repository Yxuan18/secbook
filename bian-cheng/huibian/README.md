# 汇编

### 1、课程概要

1、什么是机器语言 

加：0100 0000   
减：0100 1000   
乘：1111 0111 1110 0000   
除：1111 0111 1111 0000 

缺点：不方便记忆

2、汇编语言：

由机器语言发展而来，可用符号表示数值间的运算

加：INC EAX → 0100 0000  
减：DEC EAX 0100 1000   
乘：MUL EAX 1111 0111 1110 0000   
除：DIV EAX 1111 0111 1111 0000

优势：相对于机器语言，更简单   
劣势：不符合人类的思维范式

编译器： 可将汇编指令转换为机器语言的工具

3、C语言： 

加：A+B 0100 0000   
减：A-B 0100 1000   
乘：A\*B 1111 0111 1110 0000   
除：A/B 1111 0111 1111 0000

C语言属于高级语言，更加贴近人类的思维方式

4、C与C++的关系 

1.  C与C++其实没有本质区别，只是编译器做的事情越来越多，越来越强大
2. C语言是C++的基础

5、学习汇编的原因

1. 一个不懂汇编的人，都是不懂原理的
2. 如果从事安全行业，汇编是必须要掌握的基础（外挂开发等）
3. 对于正向开发，懂汇编可以做的更好，潜力更大

6、学习环境

1. VC6
2. VS2010，2013，2016
3. 选择VC6的原因：越是新版本的编译器，在编译的时候添加的细节代码会更多，不利于学习

win7下安装VC6：[教程链接](https://jingyan.baidu.com/article/6b1823096f76fbba58e159d3.html)，[VC6安装包](http://pcr1.pc6.com/rm/VC6.0.rar)

### 2、进制

1、学习进制的原因

计算机只认识二进制，为了更好理解计算机，就需要深刻理解进制

2、学习进制的障碍

总以十进制为依托，需要运算的时候也是先转换为10进制，这种学习方法是错误的

想要学好进制，就要先忘掉十进制，忘掉进制间的转换

3、进制的定义

| 进制 | 组成 | 规则 |
| :--- | :--- | :--- |
| 八进制 | 有八个符号组成，0 1 2 3 4 5 6 7  | 逢八进一 |
| 十进制 | 有十个符号组成，0 1 2 3 4 5 6 7 8 9 | 逢十进一 |
| N进制 | 有N个符号组成 | 逢N进一 |

4、进制的书写

在进制的运算中，没有必要对进制进行转换，可以直接进行计算

| 进制 | 写法 |
| :--- | :--- |
| 1 | 0，1，11，111，1111，11111 |
| 3 | 0，1，2，10，11，12，21，22 |
| 7 | 0，1，2，3，4，5，6，10，11，12 |

5、你能理解1+1=3吗？

学习进制，就要理解进制的深度，而不是表面现象

如果将进制用在加密解密方向，就会给解密的人带来很大的困扰

### 3、进制的运算 

每一种进制的体系都是完美的，不需要转换成其他进制进行运算

 1、八进制运算

2+3=?\(5\)  2\*3=?\(6\)  2+3=?\(5\)  4+5=?\(11\)  4\*5=?\(24\)  277+333=?\(277+333=7+3\(12\)+\(130\)+2+4\(6\)=632\)  276\*54=?\(\)  237-54=?\(\)  234/4=?\(\)  

0,1,2,3,4,5,6,7,10,11,12,13,14,15,16,17,20,21,22,23,24

2+3为从2开始，往后查3个数，其他相同

制作八进制的加法表与乘法表：

0，1，2，3，4，5，6，7，10，11，12，13，14，15，16，17，20，21，22，23，24，25，26，27

![&#x52A0;&#x6CD5;&#x8868;](../../.gitbook/assets/image%20%28236%29.png)

![&#x4E58;&#x6CD5;&#x8868;](../../.gitbook/assets/image%20%28246%29.png)

乘法表的本质，也是查询数字

 进制总结：  
每种进制都是完美的，他自身就是一个完整的体系，可以直接进行各种运算

### 4、二进制简写形式

1、计算机为什么使用二进制

计算机是需要用电的，电路只有两种状态：1 真（通电），0 假（未通电） 。  
计算机中存储的任何文件，接收的任何指令都是由0和1组成的（查看一个.exe程序）

 查看EXE文件使用工具为：UltraEdit

其中内容为：

文件的地址位：文件中的内容：UE的注释

![](../../.gitbook/assets/image%20%28261%29.png)

 2、二进制的简写形式

二进制：从0写到1111  
0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111

这种二进制使用起来太麻烦，改写成更简单一点的符号：

0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  
这就是十六进制了，中国古代时候已经开始使用十六进制了

![](../../.gitbook/assets/image%20%28260%29.png)

建议：写代码的时候要习惯十六进制，最好不要用十进制

十六进制：可读性更强

3、熟练掌握进制之间的转换

### 5、数据宽度

1、数据宽度

数学上的数字，是没有大小限制的，可以无限大，但在计算机中，由于的硬件制约，数据都是有长度限制的（数据宽度），超出宽度的数据会被丢弃

 2、计算机中常见的数据宽度

| 单位 | 宽度 | 存储范围 |
| :--- | :--- | :--- |
| 位（BIT） | 1 | 0-1 |
| 字节（BYTE） | 8 | 0-FF |
| 字（WORD） | 16 | 0-FFFF |
| 双字（DOUBLEWORD） | 32 | 0-FFFFFFFF  |

 位是计算机中存储数据的最小单位  
一个字节能存储8个位  
字有16位  
双字能存储32个位

讲解中的示例代码：

```text
// firstCreckme.cpp : defines the entry point for the console application 
//

# include "stdafx.h"
# include <stdio.h>

int main(int argc,char*argv[])
{
    char x = 0x1FF;
    // char 要使用的容器是8位的
    // int  要是用的容器是32位的
    printf("%x\n ",&x);
    
    return 0;
}
```

### 6、有符号数和无符号数

 在不同文件中，0和1的含义都是不同的

1、无符号数的编码规则

![](../../.gitbook/assets/image%20%28259%29.png)

十六进制显示的话，则是：0x9A，十进制是：154  
文件不同，解析方法不同

2、有符号数，正数编码规则：1A 

![](../../.gitbook/assets/image%20%28259%29.png)

 如果最高位是1，则为负数；如果最高位是0，则为正数

如果一个数是有符号数，且最高位是0，那么这个数一定是正数

```text
int main(int argc,char* argv[])
{
    int x = 0x1A000000;
    printf("以无符号形式显示：%v\n",x);
    printf("以有符号形式显示：%d\n",x);
    
    return 0;
}
```

当数字为正数时，有符号与无符号的显示结果是一样的

### 7、数字的编码

1、编码规则

不同的文件有不同的编码规则  
有符号数与无符号数解析成果是一样的，若首位是0  
负数的编码规则与正数不同

2、有符号数的编码规则

原码：最高位为符号位，其余各位是数值本身的绝对值  
  
反码：  
正数：反码与原码相同  
负数：符号位为1，其余位对原码取反  
  
补码：  
正数：补码与原码相同  
负数：符号位为1，其余位对原码取反加1

3、举例说明

| 例子 | 原码 | 反码 | 补码 |
| :--- | :--- | :--- | :--- |
| 1 | 0000-0001 | 0000-0001 | 0000-0001 |
| 6 | 0000-0110 | 0000-0110 | 0000-0110 |
| -1 | 1000-0001 | 1111-1110 | 1111-1111 |
| -7 | 1000-0111 | 1111-1000 | 1111-1001 |

总结：

1. 正数原码存储（编码规则）
2. 负数补码存储（编码规则）

4、假设数据宽度为1BYTE（8 BIT）

无符号数：0  1  2  3  4  5  ........  FF  （10进制255）  
有符号数：  
正数：0......7F  
负数：FF......80

![](../../.gitbook/assets/image%20%28265%29.png)

5、假设数据宽度为DOUBLEWORD（双字）

无符号数：0  1  2  3  4  5  ........  FFFFFFFF    
有符号数：  
正数：0......7FFFFFFF  
负数：FFFFFFFF......80000000

### 8、计算机的运算

计算机是通过位运算来做的运算

为什么要学习位运算？

1. 有些功能必须通过位运算才能实现：比如写调试器，判断CPU的各种状态位
2. 大公司面试题：比如2\*8的效率最高的实现方式

1、与运算 and\(&\)

两个数都为1时，结果才是1

![&#x4E24;&#x4E2A;&#x5F00;&#x5173;&#x90FD;&#x95ED;&#x5408;&#x65F6;&#xFF0C;&#x706F;&#x6CE1;&#x624D;&#x4F1A;&#x4EAE;](../../.gitbook/assets/image%20%28263%29.png)

比如：1011-0001&1011-0000=10010000

2、或运算  or \(\|\)

只要有一个为1就是1

![&#x4E00;&#x4E2A;&#x5F00;&#x5173;&#x95ED;&#x5408;&#xFF0C;&#x706F;&#x6CE1;&#x4F1A;&#x4EAE;](../../.gitbook/assets/image%20%28264%29.png)

比如：1011-0001\|1101-1000=1111-1001

3、异或运算    xor\(^\)

不一样的时候是1

![](../../.gitbook/assets/image%20%28266%29.png)

比如：1011-0001^11011000=01101001

4、非运算  not\(~\)

0就是1，1就是0  
注意：非运算只需要一个数字，单目运算

比如：1101-1000 = 0010-0111

5、移位运算

5-1、左移：  
各二进位全部左移若干位，高位丢弃，低位补0  
比如： shl\(&lt;&lt;\) 1101-1000左移2位为： 0110-0000

5-2、右移：  
各二进位全部右移若干位，低位丢弃，高位补0或者补符号位

比如：  

```text
shr 1101-0101 0011-0101    #shr补0
对应C语言（>>）
unsigned int a = 10;
printf("%d\n",a>>2);

sar 1101-0101 1111-0101    #sar补符号位
对应C语言（>>）
int a = 10;
printf("%d\n",a>>2);
```







### 9、



### 10、



### 11、



### 12、



### 13、



### 14、



### 15、



### 16、



### 17、



### 18、



### 19、



### 20、



### 21、



### 22、



### 23、



### 24、



### 25、



### 26、



